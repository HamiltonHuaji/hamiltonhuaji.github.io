---
title: 如何编写OptiFine光影包(原理篇)
date: 2022-03-03 23:48:03
mathjax: true
tags:
- Computer Graphics
- Shaderpack
---

本文将首先简要回顾蒙特卡洛光线追踪算法, 随后结合OptiFine的工作方式, 对该算法在光影包中的实现难点进行分析, 最后对主流光线追踪光影包的实现原理进行解释.

## 蒙特卡洛光线追踪

1986年, Kajiya等人提出了渲染方程, 描述几何光学近似下光与物体表面的交互过程(各符号的解释见[渲染方程](https://zh.wikipedia.org/zh-hans/渲染方程))

`$L_{\text{out}}(\vec{x}, \vec{\omega}) = \int_{\text{Hemisphere}} f_r(\vec{x}, \vec{\omega'}, \vec{\omega}) L_{\text{in}}(\vec{x}, \vec{\omega'}) (\omega' \dot \vec{n}) d\vec{\omega'}$`

作为一个积分方程, 该方程一般不具有封闭形式的解, 因此需要通过蒙特卡洛方法, 求得一个随机变量`$L(\vec{\text{eye}}, \vec{\text{vision}})$`, 使其期望为方程的解或近似解.

考虑该积分方程的一个近似, 即光线在场景中反射`$N+1$`次后就会消失, 而未反射这么多次的光线则不受影响. 显然, 当`$N\rightarrow\infty$`时, 这一近似回到真正的渲染方程. 因此方程的解可以被写为`$2N$`维的积分. 设场景全部表面为`$Sigma$`, 积分区间就是`$Sigma^N$`(将渲染方程转化为按面积的积分后即可看出). 这样的高维积分正是蒙特卡洛方法所擅长的.

而蒙特卡洛方法在求解如上积分时的每一个采样点, 都等价于`$N$`条首尾相连的路径. 除最前一条路径的头端在光源上、最后一条路径的尾端在摄像机上以外, 每条路径的两端都在场景中的能反射光的表面上. 因此沿着这些路径求取该采样点对结果的贡献的过程, 就像追踪一条假想的光线路径一样. 这就是蒙特卡洛光线追踪名称的含义.

## OptiFine的工作方式

此处我们不讨论OptiFine是如何对minecraft进行逻辑注入的, 而着眼于它组织各着色器、并提供给着色器必要的输入的方式.

// To be continued...
